%TODO: add cliffhanger with preview for next time

%variability
%code-generation
%testing

%modularity? + dependences

\input{setup}

\date{23.3.2018}

\begin{document}

\renewcommand{\enquote}[1]{\emph{``#1''}} % Cannot be done earlier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\titlepage
	\doclicenseThis
\end{frame}

\begin{frame}
	\frametitle{Organization}
	Today:
	\begin{description}
		\item[23.3.2018:] \textbf{teams found together, dates of talks}
	\end{description}
	Next dates:
	\begin{description}
		\item[13.4.2018:] \textbf{homework submitted, topics of team exercise}
		\item[27.4.2018:] lecture
		\item[4.5.2018:] lecture
		\item[18.5.2018:] guest lecture
		\item[25.5.2018:] team exercise submitted
		\item[1.6.2018:] lecture
		\item[8.6.2018:] lecture
		\item[15.6.2018:] \textbf{last corrections of team exercise}
		\item[22.6.2018:] \textbf{test}
	\end{description}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Recapitulation}

	\begin{itemize}[<+-| alert@+>]
	\item alarming trend in number and complexity of configuration settings
	\item sharing, visibility and default value calculation often helps
	\item needs abstraction: configuration specification
	\item but also more courageous decisions and periodical reevaluation
	\item different ways to reduce configuration space
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Recapitulation (Metalevels)}
	\includegraphics{metalevels}
\end{frame}

\begin{frame}
	\frametitle{Recapitulation (Requirements of SpecElektra)}

	\begin{itemize}
	\item formal and informal
	\item should strive for completeness
	\item should be extensible
	\item should be external to application
	\item open for introspection (for tooling)
	\item should talk to users
	\item should allow generation of artefacts
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{SpecElektra}

	\fontsize{18}{0}\selectfont
	\ExecuteMetaData[../book/approach.tex]{definition-spec}
\end{frame}


\begin{frame}
	\frametitle{Popular Topics}
	\vspace{-0.5cm}
	\begin{multicols}{2}
	\begin{description}
	\item[4] validation
	\item[4] user interface
	\item[3] tools (benefits?)
	\item[3] testability
	\color{gray}
	\item[3] complexity reduction (when conf. needed?)
	\item[3] architectural decisions
	\color{black}
	\item[2] Puppet
	\color{red}
	\item[2] modularity
	\color{gray}
	\item[2] environment variables
	\color{black}
	\item[2] documentation
	\color{red}
	\item[2] configuration specification
	\color{gray}
	\item[2] command-line args\color{black}
	\item[2] code generation
	\item[1] variability
	\item[1] self-description
	\item[1] round-tripping
	\color{red}
	\item[1] introspection
	\item[1] dependences
	\item[1] auto-detection
	\color{black}
	\item[1] early
	\item[1] context-awareness
	\item[1] administrators
	\end{description}
	\end{multicols}
\end{frame}

\begin{frame}
	\frametitle{Goals for today}
	\begin{itemize}
	\item modularity on system level
	\begin{itemize}
	\item horizontal
	\item vertical
	\end{itemize}
	\item system-wide introspection
	\item avoiding dependences
	\item auto-detection
	\end{itemize}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Modularity}

%TODO: disadvantages in hard-coding configuration
%TODO: disadvantages in having transformations
%TODO: disadvantages in missing introspection

%TODO: describe more configuration integration problem (req. etc.)


\begin{frame}
	\frametitle{Types of Modularity}
	\Large
	\ExecuteMetaData[../book/backend.tex]{definition-modularity}
\end{frame}

\subsection{Vertical}

\begin{frame}[fragile]
	\frametitle{Vertical Modularity \cite{raab2016improving}}

	\intro[modularity!vertical]{Vertical modularity} is the degree of separation between different applications.
	If all applications use the same key database with a single backend or a single configuration file, applications would be coupled tightly.
	[...]

	If coupling between applications is low, for example every application uses a different configuration library or a different backend, we have a high degree of vertical modularity.
\end{frame}

\begin{assignment}
	\begin{task}
	Break.
	\end{task}
\end{assignment}

\begin{frame}
	\frametitle{Retain Vertical Modularity \cite{raab2016improving}}

	\elektra{} provides two mechanisms to retain vertical modularity:

	\begin{itemize}
	\item \textbf{Mounting} configuration files facilitates different applications to use their own backend and their own configuration file.
	Furthermore, mounting enables integrating existing configuration files into the key database.
	Configuration specifications written in \elektra{Spec} allow different applications to share their configuration files with each other in a controlled way.

	%TODO: Duplicate
	\item Having frontends that implement existing \textbf{APIs} decouple applications from each other.
	These applications continue to use their specific configuration accesses, but \elektra{} redirects their configuration accesses to the shared key database.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Vertical Modularity \cite{raab2016improving}}
	Mountpoints can also be a part of the specification:

	\begin{code}[language=Cpp,gobble=4,showspaces=no]
	[ntp]
	  mountpoint:=ntp.conf
	[sw/libreoffice]
	  mountpoint:=libreoffice.conf
	\end{code}

	\begin{task}
	Which type of specification is this?
	\end{task}
\end{frame}

\begin{frame}
	\frametitle{Types of Specifications}
	\includegraphics[scale=0.8]{specifications}
\end{frame}

\begin{frame}
	\frametitle{Vertical Modularity}
	\begin{columns}[c]
	\column{7cm}
	\includegraphics[scale=0.75]{verticalmodularity}
	\column{4cm}
	Needed to keep applications independently.

	Boxes are applications, cylinders are configuration files, F? are frontends or frontend adapters, L? are configuration libraries~\cite{raab2016improving}.
	\end{columns}
\end{frame}



\subsection{Horizontal}

\begin{frame}
	\frametitle{Horizontal Modularity \cite{raab2016improving}}

	\intro[Modularity!horizontal]{Horizontal modularity} is ``the degree of separation in configuration access code''~\cite{raab2016improving}. 
	A higher degree of horizontal modularity allows us to better separate configuration access code and plug the code together as needed.
\end{frame}

\begin{frame}
	\label{slide:horizontal-modularity}
	Three factors of \elektra{Spec} improve horizontal modularity:
	\begin{enumerate}
	\item
	Using \elektra{Spec}, applications are completely decoupled from configuration specifications.

	\item
	Specifications and their implementation are decoupled.

	\item
	Abstract dependences within the implementation of specifications.
	\end{enumerate}

	\begin{task}
	This is very vague.

	Can you describe a system that would (not) fulfil this?
	\end{task}
\end{frame}

\begin{frame}
	\frametitle{Horizontal Modularity}
	\begin{columns}[c]
	\column{7cm}
	\includegraphics[scale=0.95]{horizontalmodularity}
	\column{4cm}
	Needed mainly for validation. \\[1cm]

	Cylinders are configuration files, P? are plugins~\cite{raab2016improving}
	\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Plugins}

\subsection{Why?}

\begin{frame}[fragile]
	\frametitle{Acceptable Effort}

	\methodQuestion{} \question{Which effort do you think is worthwhile for providing better configuration experience?}

	\begin{itemize}
	\item \p{44} would use other configuration access APIs next to ^getenv^.
	\item \p{30} would use OS-specific sources.
	\item \p{21} would use dedicated libraries.
	\item \p{19} would read other application's configuration settings,
	\item \p{16} would use external configuration access APIs that add new dependences.
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Why?}
	\begin{finding}
	\methodQuestion{}
	Most developers have concerns adding dependences for more validation~(\p{84}) but consider good defaults important (\p{80}).
	\end{finding}

	\begin{restatable}{requirement}{reqDependences}
	\label{req:dependences}
	Dependences exclusively needed to validate configuration settings must be avoided.
	\end{restatable}
\end{frame}

\begin{frame}
	\frametitle{Rationale}
	Why is it difficult to have good defaults?
	\begin{itemize}[<+->]
	\item \textbf{Modularity:} diverse and conflicting requirements between applications.
	Especially in validation, for example, \linebreak
	constraint solvers vs. type systems vs. model checkers.
	\item \textbf{System-level:} specification must always be enforced. Examples:
	\begin{itemize}[<+-| alert@+>]
	\item which desktop is the application started in?
	\item how many CPUs does the system have?
	\item get the correct proxy of the system.
	\item get available network bandwidth.
	\item is the filesystem local?
	\end{itemize}
	\end{itemize}
\end{frame}

\subsection{How?}

\begin{frame}
	\Large
	\ExecuteMetaData[../book/approach.tex]{definition-plugins}
\end{frame}

\begin{frame}
	\frametitle{KeySet}

	The common data structure between plugins:
	\vspace{1cm}

	\includegraphics{keyset}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Plugin Assembly}

	automatic assembling of plugins:

	\begin{itemize}[<+->]
	\item iterate over the specification and collect all key words
	\item iterate over all plugins and check if they offer key words
	\item check contract between plugins and specification
	\item of the remaining plugins: use best suited or rated
	\end{itemize}

	\vspace{1cm}

	\pause[\thebeamerpauses]

	(implemented in ^kdb mount^ / ^kdb spec-mount^ in Elektra)
\end{frame}

\begin{frame}
	SpecElektra is a dependency injection mechanism:

	\begin{itemize}[<+->]
	\item By extending the specification, new plugins are being injected into the system.
	\item The \empha{provider} abstractions in the dependences between the plugins abstract over concrete implementations of configuration access code.
	\item We have a modular implementation of SpecElektra.
	\end{itemize}

	\onslide<+->{
	\begin{task}
	Which kind of modularity does \empha{provider} improve?
	\end{task}
	}

	\onslide<+->{
	\begin{answer}
	3\textsuperscript{rd} point of horizontal modularity on Slide~\ref{slide:horizontal-modularity}
	\end{answer}
	}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Examples}
	calculation with context:
	\begin{code}[gobble=4]
	[gps/status]
	assign:=(battery > 'low') ? ('on') : ('off')
	[battery]
	plugins:=battery
	\end{code}

	\pause
	\vspace{1cm}

	other example: how to resolve names of configuration files on an operating system
\end{frame}


\begin{frame}
	\frametitle{Preview}
	next lecture after eastern:
	\begin{itemize}
	\item code generation vs. introspection
	\item testability
	\end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\nocite{raab2016improving}

\appendix

\begin{frame}[allowframebreaks]
	\bibliographystyle{plainnat}
	\bibliography{../shared/elektra.bib}
\end{frame}

\end{document}


