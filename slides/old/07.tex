%TODO: add cliffhanger with preview for next time
%TODO: recapitulate the team work?
%TODO: examples requirements vs. context

\input{setup}

\date{29.05.2019}

\begin{document}

\renewcommand{\enquote}[1]{\emph{``#1''}} % Cannot be done earlier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\titlepage
	\doclicenseThis
\end{frame}

\begin{frame}
	Lecture is every week Wednesday 09:00 - 11:00.

	\begin{description}
		\item[06.03.2019:] {\color{gray}topic, teams}
		\item[13.03.2019:] {\color{gray}TISS registration, initial PR}
		\item[20.03.2019:] {\color{gray}other registrations, guest lecture}
		\item[27.03.2019:] {\color{gray}PR for first issue done, second started}
		\item[03.04.2019:] {\color{gray}first issue done, PR for second}
		\item[10.04.2019:] {\color{gray}mid-term submission of exercises}
		\item[08.05.2019:] {\color{gray}different location: Complang Libary}
		\item[15.05.2019:]
		\item[22.05.2019:] {\color{gray}all 5 issues done}
		\item[29.05.2019:]
		\item[05.06.2019:] final submission of exercises
		\item[12.06.2019:]
		\item[19.06.2019:] last corrections of exercises
		\item[26.06.2019:] exam
	\end{description}
\end{frame}

\begin{assignment}
	\frametitle{Tasks for today}
	(until 29.05.2019 23:59)

	\begin{task}
	Continue teamwork and homework.
	Make a clear description for what your team partner should do.
	\end{task}
\end{assignment}

\begin{assignment}
	\frametitle{Tasks for next week}
	(until 05.06.2019 23:59)

	\begin{task}
	Submit teamwork and homework.
	\end{task}
\end{assignment}

\begin{frame}
	\frametitle{Popular Topics}
	\vspace{-0.55cm}
	\setlength{\columnsep}{-1.3cm}
	\raggedright
	\definecolor{amethyst}{rgb}{0.6, 0.4, 0.8}
	\begin{multicols}{2}
	\begin{description}
	\item[14] {\color{red} tools}
	\item[9] {\color{gray} testability}
	\item[9] {\color{gray} code-generation}
	\item[7] {\color{red} context-awareness}
	\item[6] {\color{red} specification}
	\item[6] {\color{gray} misconfiguration}
	\item[6] {\color{gray} complexity reduction}
	\item[5] validation
	\item[5] {\color{gray} points in time} % (early detection)
	\item[5] error messages
	\item[5] {\color{gray} auto-detection}
	\item[4] user interface
	\item[4] {\color{gray} introspection}
	\item[4] {\color{red} design}
	\item[4] {\color{gray} cascading}
	\item[4] {\color{gray} architecture of access}
	\item[3] {\color{gray} configuration sources}
	\item[3] {\color{gray} config-less systems}
	\item[2] secure conf
	\item[2] {\color{gray} architectural decisions}
	\item[1] push vs.\ pull
	\item[1] {\color{red} infrastructure as code}
	\item[1] full vs.\ partial
	\item[1] convention over conf %iguration
	\item[1] CI/CD
	\item[0] {\color{amethyst} documentation}
	\end{description}
	\end{multicols}
\end{frame}


\begin{frame}
	\frametitle{Learning Outcomes}
	Students will be able to
	\begin{itemize}
	\item remember basics of context-awareness.
	\item remember basic characteristics of key databases.
	\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}
	\frametitle{Introspection (Recapitulation)}
	\begin{task}
	What is internal and external specification?
	What is introspection?
	\end{task}

	\pause
	\vspace{1em}

	\begin{itemize}
	\item \textit{internal}: within applications' source code
	\item \textit{introspection}: unified get/set access to (meta*)-key/values
	\item access via applications, CLI, GUI, web-UI, ...
	\item access via any programming language (similar to file systems)
	\item GUI, web-UI can semantically interpret metadata
	\item assemble modular parts (validation, logging, \dots)
	\item needed as communication between producers and consumers
	\item essential for \intro[no-futz computing]{no-futz computing}~\citet{holland2001nofutz}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Example Documentation (Recapitulation)}

	\begin{code}[gobble=4]
	[slapd/threads/listener]
	  check/range:=1,2,4,8,16
	  default:=1
	  description:=adjust to use more threads
	  rationale:=needed for many-core systems
	  requirement:=1234
	  visibility:=user
	\end{code}
\end{frame}

\begin{frame}
	\frametitle{Reevaluate specifications (Recapitulation)}

	\begin{task}
	In which situations should you reevaluate if a configuration setting (specification) is needed?
	\end{task}

	\pause

	\ExecuteMetaData[../book/implications.tex]{reasons-adding}

	\begin{alertblock}{Goal}
	Reduction of all not-needed configuration settings (user view).
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Semantic three-way merge (Recapitulation)}

	\textbf{Ours:}
	\begin{code}[gobble=4,language=CfgElektra]
	slapd/threads/listener=4

	slapd/threads/enable= \
		yes # must be enabled for listener

	\end{code}

	\textbf{Theirs:}
	\begin{code}[gobble=4,language=CfgElektra]
	slapd/threads/enable = on
	slapd/threads/listener = 8
	\end{code}

	\textbf{Origin:}
	\begin{code}[gobble=4,language=CfgElektra]
	slapd/threads/listener=8
	slapd/threads/enable = true
	\end{code}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Context-Awareness}

\subsection{}

\begin{frame}
	\citet{khalil2005context} conducted a study where all users found context-aware configuration (very) useful.
	They learned that in \p{89} of cases the mapping between activities and settings was consistent for individual users.
	In the study, context-aware configuration improved satisfaction, even if deduced settings sometimes were not appropriate.
	For example, a participant stated:
	\vspace{2em}

	\begin{quote}
	``I like how it changes state without you having to tell it to. I always forget to turn my cell [off] in class and turn it on after.''
	\end{quote}
\end{frame}

\begin{frame}
	\frametitle{Definition (Recapitulation)}
	\ExecuteMetaData[../book/background.tex]{context-definition}
\end{frame}

\begin{frame}
	\frametitle{Types of Configuration (Recapitulation)}
	\pause
	\begin{description}
	\ExecuteMetaData[../book/background.tex]{context-types}
	\end{description}
\end{frame}

\begin{frame}
	\frametitle{Cascading (Recapitulation)}
	\includegraphics{cascading}
\end{frame}

\begin{frame}
	\frametitle{Context-oriented Programming}
	\ExecuteMetaData[../book/background.tex]{context-oriented-programming}
\end{frame}

\begin{frame}
	\frametitle{Contextual Values}
	\ExecuteMetaData[../book/background.tex]{contextual-values}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Contextual Values (Pseudocode)}

	\begin{code}[gobble=4,language=C++,morekeywords={context}]
	void printBrowserConfig (Config config)
	{
		context.with("private")
		{
			println (config.keepHistory);
		}
		// same thread, different context:
		println (config.keepHistory);

		context.activate(currentLocation)
	}
	\end{code}
\end{frame}
\begin{frame}
	\frametitle{Introspection vs. Code Generation (Partly Recapitulation)}

	Implementation of contextual values might be in key database or in generated code.
	Advantages of having it in key database (with introspection)?

	\pause

	\setbeamersize{description width=1cm}
	\begin{description} %[leftmargin=0cm] %TODO: move left
	\item[$-$] more techniques for performance improvements with code generation
	\item[$+$] specification can be updated live on the system without recompilation
	\item[$+$] tooling has generic access to all specifications
 	\item[$+$] new features the key database (e.g., better validation) are immediately available consistently
	\item[$-$] \color{red} needed if context differs within same thread
	\end{description}

	\vspace{0.5em}

	\begin{alertblock}{Implication}
	We generally prefer introspection, except for a very thin configuration access API.
	\end{alertblock}
\end{frame}


\begin{assignment}
	\begin{task}
	Break.
	\end{task}
\end{assignment}

\begin{frame}
	\frametitle{Types of Specifications (Recapitulation)}
	\includegraphics[scale=0.8]{specifications}
\end{frame}

\begin{frame}
	\frametitle{Keys as Contextual Values}

	\begin{itemize}[<+-| alert@+>]
	\item keys can be interpreted as contextual values~\cite{raab2016persistent,raab2017introducing}
	\item we can make contextual values dependent on contextual values
	\item we can also use keys to describe requirements
	\item if we use a predefined path in Elektra for layers, we can activate context by writing to KDB
	\item this is implemented in ``kdb elektrify-getenv''
	\end{itemize}

	\pause[\thebeamerpauses]

	\begin{alertblock}{Implication}
	The configuration can fully describe the context and the requirements.
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Context Specifications}

	\begin{itemize}
	\item
	Determine threads from CPUs:

	\begin{code}[gobble=4]
	[env/layer/cpu]
	  type:=long
	[slapd/threads/listener]
	  context:=/slapd/threads/%cpu%/listener
	\end{code}

	\item
	Determine vibration from sensors:

	\begin{code}[gobble=4]
	[phone/call/vibration]
	  type:=boolean
	  context:=/phone/call/%inpocket%/vibration
	\end{code}

	\item
	Determine proxy settings from network:

	\begin{code}[gobble=4]
	[env/override/http_proxy]
	  context:=/http_proxy/%interface%/%network%
	\end{code}
	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{Conclusion}

	\begin{itemize}[<+-| alert@+>]
	\item Context-awareness is a goal.
	\item Contextual values is a way to implement it.
	\item Many (distributed) key databases enable us to persist configuration settings.
	\item Definition and challenges in configuration management.
	\item Cloning: There and back again.
	\end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Key Databases}

\subsection{}

\begin{frame}
	\frametitle{Status Quo}

	Applications \dots

	\begin{itemize}
	\item usually consume configuration settings from configuration files, command-line arguments, and environment variables.
	\item sometimes have a single GUI or CLI for configuration settings.
	\item rarely have an API to access configuration settings.
	\item rarely consider context.
	\item rarely do in-depth validation.
	\item nearly never have an API to access configuration specifications.
	\end{itemize}

	\begin{task}
	Think about applications you know.
	Discuss it with your neighbor.
	\end{task}
\end{frame}

\begin{frame}
	\frametitle{Examples}

	\begin{itemize}
	\item Postfix\footnote{\url{http://www.postfix.org/OVERVIEW.html}}: CLI (Properties, CSV, and others)
	\item KDE\footnote{\url{https://api.kde.org/frameworks/kconfig/html/}}: GUI, CLI (INI)
	\item Libreoffice: GUI (XML)
	\item Firefox~\cite{jin2014configurations}: GUI (JavaScript and others)
	\item sudo: CLI (sudoers edited with visudo)
	\item X.org\footnote{\url{ftp://www.x.org/pub/X11R6.7.0/doc/xorg.conf.5.html}}: xorg.conf
	\item gpsd\footnote{\url{http://www.aosabook.org/en/gpsd.html}}: environment variables and command-line arguments
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Design Decisions}

	There are many ways to design configuration access but many decisions are only pragmatic and irrelevant with proper key/value abstraction.

	\begin{task}
	Which design decisions are there?
	Why are they (ir)relevant?
	\end{task}

	\pause

	\begin{itemize}
	\item Which configuration file format? (irrelevant due to key/values)
	\item Split up into multiple configuration files? (irrelevant due to 3-way merging)
	\item Where are the configuration files? (irrelevant due to mounting and resolver)
	\item Important: Introspection, Validation, Horizontal Modularity, Integration,
		Specification, API, Guarantees, \dots
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Key Databases (Usage)}

	\methodQuestion{} \question{Which configuration systems/libraries/APIs have you already used or would like to use in one of your FLOSS project(s)?}

	\begin{itemize}
	\item Command-line arguments (\p{92}, $n=222$)
	\item environment variables (\p{79}, $n=218$)
	\item configuration files (\p{74}, $n=218$)
	\item Freedesktop standards (\p{20}, $n=205$)
	\item Windows Registry (\p{13}) ($\leq$ \p{13}, $n\geq185$) [talk later]
	\item X/Q/GSettings (\p{4}, \p{11}, \p{9})
	\item KConfig (\p{5})
	\item dconf (\p{7})
	\item plist (\p{7})
	\end{itemize}

\end{frame}

\begin{frame}
	\frametitle{Distributed Key Databases}

	Examples:

	\begin{itemize}
	\item Redis: in-memory with persistence and notification
	\item Zookeeper
	\item etcd:
		\begin{itemize}
		\item not in-memory
		\item get/set/watch interface via REST
		\item distributed coordination~\cite{ongaro2014search}
		\item needs configuration itself
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Elektra}

	\begin{itemize}
	\item is not only a key database but a specification language to describe a key database
	\item plugins implement the specification (could be distributed but focus is configuration files)
	\item is library based (no single point of failure, no distributed coordination needed)
	\item supports transactions (persisting whole KeySets at once)
	\item supports integration of existing configuration
	\end{itemize}
\end{frame}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\nocite{raab2017introducing}

\appendix

\begin{frame}[allowframebreaks]
	\bibliographystyle{plainnat}
	\bibliography{../shared/elektra.bib}
\end{frame}

\end{document}


%TODO: add cliffhanger with preview for next time
